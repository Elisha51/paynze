
import type { Notification, Order } from '@/lib/types';
import { subHours, subMinutes, subDays } from 'date-fns';
import { getStaffOrders } from './staff';

const LOGGED_IN_STAFF_ID = 'staff-003';

// This is a frontend simulation of a notification service.
// In a real backend, these would be generated by events.
let notifications: Notification[] = [];

async function generateNotifications() {
    const assignedOrders = await getStaffOrders(LOGGED_IN_STAFF_ID);
    const todoOrders = assignedOrders.filter(order => !['Delivered', 'Picked Up', 'Cancelled'].includes(order.status));

    const generatedNotifications: Notification[] = [];

    // Create notifications for each "to do" order
    todoOrders.forEach((order, index) => {
        generatedNotifications.push({
            id: `notif_task_${order.id}`,
            type: 'task-assigned',
            title: `New delivery assigned: Order #${order.id}`,
            description: `A new delivery for customer ${order.customerName} has been assigned to you.`,
            timestamp: subMinutes(new Date(), 5 * (index + 1)).toISOString(),
            read: false,
            link: `/dashboard/orders/${order.id}`,
        });
    });

    // Add some other generic notifications for variety
    generatedNotifications.push({
        id: 'notif_low_stock_1',
        type: 'low-stock',
        title: 'Low Stock Warning',
        description: 'Product "Handmade Leather Shoes - Size 42" is low on stock (2 available).',
        timestamp: subHours(new Date(), 2).toISOString(),
        read: false,
        link: '/dashboard/products/SHOE-002',
    });
     generatedNotifications.push({
        id: 'notif_completed_1',
        type: 'new-order',
        title: 'Order #ORD-001 completed',
        description: 'You successfully delivered the order to Olivia Smith.',
        timestamp: subDays(new Date(), 1).toISOString(),
        read: true,
        link: '/dashboard/orders/ORD-001',
    });
    
    notifications = generatedNotifications;
}

// Initialize notifications
generateNotifications();


export async function getNotifications(): Promise<Notification[]> {
    // In a real app, you'd fetch this for the logged-in user.
    // Here we regenerate them on each call for simulation consistency
    await generateNotifications();
    await new Promise(resolve => setTimeout(resolve, 300));
    return notifications.sort((a,b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
}

export async function markNotificationAsRead(id: string): Promise<boolean> {
    await new Promise(resolve => setTimeout(resolve, 100));
    const notification = notifications.find(n => n.id === id);
    if (notification) {
        notification.read = true;
        return true;
    }
    return false;
}

export async function markAllNotificationsAsRead(): Promise<boolean> {
     await new Promise(resolve => setTimeout(resolve, 100));
    notifications.forEach(n => n.read = true);
    return true;
}
